from pathlib import Path
import torch
import imageio
import os
import numpy as np
from torch.autograd import Variable


def to_var(tensor, mps=False):
    """Wraps a Tensor in a Variable, optionally placing it on the GPU.

    Arguments:
        tensor: A Tensor object.
        mps: A boolean flag indicating whether to use the GPU.

    Returns:
        A Variable object, on the GPU if cuda==True.
    """
    if mps:
        return Variable(tensor.to(torch.device("mps")))
    else:
        return Variable(tensor)


def gan_checkpoint(iteration, G, D, opts):
    """Saves the parameters of the generator G and discriminator D."""
    parent_path = Path(__file__).parent.parent

    G_path = parent_path / opts.checkpoint_dir / "G.pkl"
    # G_path = os.path.join(opts.checkpoint_dir, 'G.pkl')
    D_path = parent_path / opts.checkpoint_dir / "D.pkl"
    # D_path = os.path.join(opts.checkpoint_dir, 'D.pkl')
    torch.save(G.state_dict(), G_path)
    torch.save(D.state_dict(), D_path)


def cyclegan_checkpoint(iteration, G_XtoY, G_YtoX, D_X, D_Y, opts):
    """Saves the parameters of both generators G_YtoX, G_XtoY and discriminators D_X, D_Y."""
    G_XtoY_path = os.path.join(opts.checkpoint_dir, "G_XtoY.pkl")
    G_YtoX_path = os.path.join(opts.checkpoint_dir, "G_YtoX.pkl")
    D_X_path = os.path.join(opts.checkpoint_dir, "D_X.pkl")
    D_Y_path = os.path.join(opts.checkpoint_dir, "D_Y.pkl")
    torch.save(G_XtoY.state_dict(), G_XtoY_path)
    torch.save(G_YtoX.state_dict(), G_YtoX_path)
    torch.save(D_X.state_dict(), D_X_path)
    torch.save(D_Y.state_dict(), D_Y_path)


def load_checkpoint(opts, generator, discriminator):
    """Loads the generator and discriminator models from checkpoints."""
    G_XtoY_path = os.path.join(opts.load, "G_XtoY.pkl")
    G_YtoX_path = os.path.join(opts.load, "G_YtoX.pkl")
    D_X_path = os.path.join(opts.load, "D_X.pkl")
    D_Y_path = os.path.join(opts.load, "D_Y.pkl")

    G_XtoY = generator(
        conv_dim=opts.g_conv_dim, init_zero_weights=opts.init_zero_weights
    )  # CycleGenerator
    G_YtoX = generator(
        conv_dim=opts.g_conv_dim, init_zero_weights=opts.init_zero_weights
    )  # CycleGenerator
    D_X = discriminator(conv_dim=opts.d_conv_dim)  # DCDiscriminator
    D_Y = discriminator(conv_dim=opts.d_conv_dim)  # DCDiscriminator

    G_XtoY.load_state_dict(
        torch.load(G_XtoY_path, map_location=lambda storage, loc: storage)
    )
    G_YtoX.load_state_dict(
        torch.load(G_YtoX_path, map_location=lambda storage, loc: storage)
    )
    D_X.load_state_dict(torch.load(D_X_path, map_location=lambda storage, loc: storage))
    D_Y.load_state_dict(torch.load(D_Y_path, map_location=lambda storage, loc: storage))

    if torch.cuda.is_available():
        G_XtoY.cuda()
        G_YtoX.cuda()
        D_X.cuda()
        D_Y.cuda()
        print("Models moved to GPU.")

    return G_XtoY, G_YtoX, D_X, D_Y


def merge_images(sources, targets, opts):
    """Creates a grid consisting of pairs of columns, where the first column in
    each pair contains images source images and the second column in each pair
    contains images generated by the CycleGAN from the corresponding images in
    the first column.
    """
    _, _, h, w = sources.shape
    row = int(np.sqrt(opts.batch_size))
    merged = np.zeros([3, row * h, row * w * 2])
    for idx, s, t in zip(
        range(row**2),
        sources,
        targets,
    ):
        i = idx // row
        j = idx % row
        merged[:, i * h : (i + 1) * h, (j * 2) * h : (j * 2 + 1) * h] = s
        merged[:, i * h : (i + 1) * h, (j * 2 + 1) * h : (j * 2 + 2) * h] = t
    return merged.transpose(1, 2, 0)


def create_image_grid(array, ncols=None):
    """ """
    num_images, channels, cell_h, cell_w = array.shape
    if not ncols:
        ncols = int(np.sqrt(num_images))
    nrows = int(np.floor(num_images / float(ncols)))
    result = np.zeros((cell_h * nrows, cell_w * ncols, channels), dtype=array.dtype)
    for i in range(0, nrows):
        for j in range(0, ncols):
            result[i * cell_h : (i + 1) * cell_h, j * cell_w : (j + 1) * cell_w, :] = (
                array[i * ncols + j].transpose(1, 2, 0)
            )

    if channels == 1:
        result = result.squeeze()
    return result


def gan_save_samples(G, fixed_noise, iteration, opts):
    generated_images = G(fixed_noise)
    generated_images = to_data(generated_images)

    grid = create_image_grid(generated_images)

    # merged = merge_images(X, fake_Y, opts)
    path = (
        Path(__file__).parent.parent
        / opts.sample_dir
        / "sample-{:06d}.png".format(iteration)
    )
    image_array_uint8 = (grid * 255).astype(np.uint8)
    imageio.imwrite(path, image_array_uint8)
    print("Saved {}".format(path))


def to_data(x):
    """Converts variable to numpy."""
    if torch.cuda.is_available():
        x = x.cpu()
    return x.data.numpy()


def cyclegan_save_samples(iteration, fixed_Y, fixed_X, G_YtoX, G_XtoY, opts):
    """Saves samples from both generators X->Y and Y->X."""
    fake_X = G_YtoX(fixed_Y)
    fake_Y = G_XtoY(fixed_X)

    X, fake_X = to_data(fixed_X), to_data(fake_X)
    Y, fake_Y = to_data(fixed_Y), to_data(fake_Y)

    merged = merge_images(X, fake_Y, opts)
    path = os.path.join(opts.sample_dir, "sample-{:06d}-X-Y.png".format(iteration))
    image_array_uint8 = (merged * 255).astype(np.uint8)
    imageio.imwrite(path, image_array_uint8)
    print("Saved {}".format(path))

    merged = merge_images(Y, fake_X, opts)
    path = os.path.join(opts.sample_dir, "sample-{:06d}-Y-X.png".format(iteration))
    image_array_uint8 = (merged * 255).astype(np.uint8)
    imageio.imwrite(path, image_array_uint8)
    print("Saved {}".format(path))


def print_models(G_XtoY, G_YtoX, D_X, D_Y):
    """Prints model information for the generators and discriminators."""
    if G_YtoX:
        print("                 G_XtoY                ")
        print("---------------------------------------")
        print(G_XtoY)
        print("---------------------------------------")

        print("                 G_YtoX                ")
        print("---------------------------------------")
        print(G_YtoX)
        print("---------------------------------------")

        print("                  D_X                  ")
        print("---------------------------------------")
        print(D_X)
        print("---------------------------------------")

        print("                  D_Y                  ")
        print("---------------------------------------")
        print(D_Y)
        print("---------------------------------------")
    else:
        print("                 G                     ")
        print("---------------------------------------")
        print(G_XtoY)
        print("---------------------------------------")

        print("                  D                    ")
        print("---------------------------------------")
        print(D_X)
        print("---------------------------------------")


def create_model(opts, generator, discriminator):
    """Builds the generators and discriminators."""
    if opts.Y is None:
        ### GAN
        G = generator(
            noise_size=opts.noise_size, conv_dim=opts.g_conv_dim
        )  # DCGenerator
        D = discriminator(conv_dim=opts.d_conv_dim)  # DCDiscriminator

        print_models(G, None, D, None)

        if torch.cuda.is_available():
            G.cuda()
            D.cuda()
            print("Models moved to GPU.")
        return G, D

    else:
        ### CycleGAN
        G_XtoY = generator(
            conv_dim=opts.g_conv_dim, init_zero_weights=opts.init_zero_weights
        )  # DCGenerator
        G_YtoX = generator(
            conv_dim=opts.g_conv_dim, init_zero_weights=opts.init_zero_weights
        )  # DCGenerator
        D_X = discriminator(conv_dim=opts.d_conv_dim)  # DCDiscriminator
        D_Y = discriminator(conv_dim=opts.d_conv_dim)  # DCDiscriminator

        print_models(G_XtoY, G_YtoX, D_X, D_Y)

        if torch.cuda.is_available():
            G_XtoY.cuda()
            G_YtoX.cuda()
            D_X.cuda()
            D_Y.cuda()
            print("Models moved to GPU.")
        return G_XtoY, G_YtoX, D_X, D_Y


def print_opts(opts):
    """Prints the values of all command-line arguments."""
    print("=" * 80)
    print("Opts".center(80))
    print("-" * 80)
    for key in opts.__dict__:
        if opts.__dict__[key]:
            print("{:>30}: {:<30}".format(key, opts.__dict__[key]).center(80))
    print("=" * 80)
